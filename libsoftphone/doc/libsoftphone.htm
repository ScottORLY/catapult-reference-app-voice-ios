<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" >
<head>
    <title>libsoftphone</title>
    <style type="text/css" media="all">
body
{
	margin: 2em;
	padding: 0;
	font-family: Cambria, Times New Roman, Serif;
	font-size: x-large;
	background-color: #ffe1aa;
}

img#Logo
{
	float: right;
}

p
{
	text-align: justify;
}

code
{
	font-family: Consolas, Courier New, Monospace;
	color: #900;
}

a
{
	color: #00f;
	text-decoration: none;
}

a:hover
{
	text-decoration: underline;
}
    </style>
</head>
<body>

    <img id="Logo" src="libsoftphone_logo.png" alt="Acrobits Logo" />

    <h1>Acrobits libsoftphone</h1>
    <p>&copy; 2011-2012 Acrobits, s.r.o</p>
    <p><a href="http://www.acrobits.cz/">http://www.acrobits.cz/</a></p>
    
    <h2>Table of Contents</h2>
    <ol>
        <li>
            <p><a href="#General">General</a></p>
            <ul>
                <li><p><a href="#ApplicationStartup">Application Startup</a></p></li>
                <li><p><a href="#ApplicationShutdown">Application Shutdown</a></p></li>
            </ul>
        </li>
        <li>
            <p><a href="#Account">Account</a></p>
            <ul>
                <li><p><a href="#AccountFormat">Account Format</a></p></li>
                <li><p><a href="#AccountExample">Account Example</a></p></li>
            </ul>
        </li>
        <li><p><a href="#Preferences">Preferences</a></p></li>
        <li>
            <p><a href="#Interface">Interface</a></p>
            <ul>
                <li><p><a href="#InstanceSystem">Instance::System</a></p></li>
                <li><p><a href="#InstanceRegistration">Instance::Registration</a></p></li>
                <li><p><a href="#InstanceCalls">Instance::Calls</a></p></li>
                <li><p><a href="#InstanceAudio">Instance::Audio</a></p></li>
                <li><p><a href="#InstanceLog">Instance::Log</a></p></li>
                <li><p><a href="#InstanceSettings">Instance::Settings</a></p></li>
            </ul>
        </li>
    </ol>
    
    <h2 id="General">General</h2>
    
    <h3 id="ApplicationStartup">Application Startup</h3>
    
    <p><code>libsoftphone</code> uses low-level Unix sockets for UDP communication.
    Writing to the socket can cause a SIGPIPE signal to be generated, in case the
    output socket buffer is full. It's recommended to block the SIGPIPE signal
    in the main application thread. An example code is in <code>main.mm</code> file
    of the <code>demophone</code> project.</p>
    
    <p><code>libsoftphone</code> needs to manage the audio session of the running
    application. When there is no call active, the audio session category is set to
    <code>kAudioSessionCategory_AmbientSound</code>, which should allow common
    notification sounds to be played as usual from the iPhone speakerphone. When
    in call, the session category changes to <code>kAudioSessionCategory_PlayAndRecord</code>.</p>
    
    <h3 id="ApplicationShutdown">Application Shutdown</h3>
    
    <p>iPhone application normally quits immediately after the user clicks the
    square button. In case a SIP user agent is registered, it is a good practice
    to unregister it at this point, instead of letting it expire.</p>
    
    <p>iPhone OS gives the apps approximately 7 seconds to quit after the square
    button is pressed, if the app doesn't quit on time, it's killed and a crashlog
    is generated. This time is usually sufficient to manage the unregistration.
    The example code is in <code>applicationWillTerminate</code> method, the
    <code>unregister()</code> is called and the current runloop is ran until
    the process completes, but not longer than 4&ndash;5 seconds.</p>
    
    <h2 id="Account">Account</h2>
    
    <h3 id="AccountFormat">Account Format</h3>
    
    <p>SIP Accounts are specified in an XML format, where SIP credentials and
    various other options are specified. Below is a description of the recognized
    XML nodes and their values.</p>
    
    <dl>
        <dt><code>&lt;username&gt;johndoe&lt;/username&gt;</code></dt>
        <dd>
            <p>No default value.</p>
            <p>SIP user name.</p>
        </dd>
        
        <dt><code>&lt;password&gt;secretPhrase&lt;/password&gt;</code></dt>
        <dd>
            <p>No default value.</p>
            <p>SIP password.</p>
        </dd>

        <dt><code>&lt;userDisplayName&gt;John Doe&lt;/userDisplayName&gt;</code></dt>
        <dd>
            <p>Default Value: empty string</p>
            <p>SIP display user name, comes quoted in front of SIP uri.</p>
        </dd>

        <dt><code>&lt;authUsername&gt;johndoe&lt;/authUsername&gt;</code></dt>
        <dd>
            <p>Default Value: empty string</p>
            <p>Username used in SIP authorization headers. If left empty, the username is used.</p>
        </dd>

        <dt><code>&lt;userCallerId&gt;John Doe&lt;/userCallerId&gt;</code></dt>
        <dd>
            <p>Default Value: empty string</p>
            <p>If set, this value will be sent in the From: field in outgoing INVITE requests. In case it's left empty, username will be used</p>
        </dd>

        <dt><code>&lt;host&gt;sip.example.com[:port]&lt;/host&gt;</code></dt>
        <dd>
            <p>No default value.</p>
            <p>SIP domain, used in SIP URIs as <code>username@host</code>.
            The SIP domain is also used as a SIP server to connect to, in case
            <code>&lt;proxy&gt;</code> is not specified. If no port is specified, 5060 is the default.</p>
        </dd>
	
	<dt><code>&lt;listeningPort&gt;5060&lt;/listeningPort&gt;</code></dt>
	<dd>
		<p>Default value: <code>(empty)</code></p>

		<p>The local port which the SIP stack will bind to:</p>

		<ul>
			<li>
				If left empty, the SIP stack will choose a random port number and will bind to it. This number will remain the same for at least one day. If the client is restarted and re-registers repeatedly, it will remember its rinstance, callId and CSeq numbers, port will remain the same and therefore it should always occupy the same registration slot on the server.
			</li>
			<li>
				If set to 0, a random port will be chosen every time the client registers.
			</li>
			<li>
				If set to a specific numeric value, the SIP stack will always bind to that port.
			</li>
		</ul>
	</dd>

        <dt><code>&lt;proxy&gt;proxy.example.com[:port]&lt;/proxy&gt;</code></dt>
        <dd>
            <p>Default Value: empty string</p>
            <p>Address of SIP proxy server to connect to. If no port is specified, 5060 is used. The final address
            of the SIP server is determined as follows:</p>
            
            <ul>
                <li>
                    <p>if <code>&lt;proxy&gt;</code> is empty,
                    address = <code>&lt;host&gt;</code>,
                    otherwise address = <code>&lt;proxy&gt;</code></p>
                </li>
                <li>
                    <p>if address is not numeric (a.b.c.d) and port is not specified in address, do a SRV DNS resolution for <code>_sip._udp.address</code>
                    (or <code>_sip._tcp.address</code>)</p>
                    
                    <ul>
                        <li>
                            <p>if SRV record exists, address = DNSResultAddress:DNSResultPort</p>
                        </li>
                        <li>
                            <p>else use address</p>
                        </li>
                    </ul>
                </li>
                <li>
                    <p>else use address</p>
                </li>
            </ul>
        </dd>

        <dt><code>&lt;transport&gt;udp&lt;/transport&gt;</code></dt>
        <dd>
            <p>Valid values: <code>udp</code>, <code>tcp</code>, <code>tls</code> and <code>tls+sip:</code></p>
            <p>Default value: <code>udp</code>.</p>
            <p>The transport protocol to use when communicating with SIP server. Transport "tls" uses sips: URIs in headers and the traffic is protected by TLS, tls+sip is also TLS-protected, but uses sip: URIs</p>
        </dd>

        <dt><code>&lt;codecOrder&gt;9,0,8,102,3,18&lt;/codecOrder&gt;</code></dt>
        <dd>
            <p>Valid value is a comma separated list of codec numbers.</p>
            <p>No default value.</p>
            
            <p>The order of codecs, as it will be offered in SDP
            for calls made with Wifi CodecSet.</p>
            
            <p>Supported codecs are:</p>
            
            <dl>
                <dt>0</dt>
                <dd><p>G711 &mu;-law</p></dd>
                
                <dt>3</dt>
                <dd><p>GSM</p></dd>
                
                <dt>8</dt>
                <dd><p>G711 a-law</p></dd>
                
                <dt>9</dt>
                <dd><p>G722 wideband codec</p></dd>

                <dt>102</dt>
                <dd><p>iLBC</p></dd>

                <dt>18</dt>
                <dd><p>G729</p></dd>
            </dl>
        </dd>
        
        <dt><code>&lt;codecOrder3G&gt;18,102,3,9,0,8&lt;/codecOrder3G&gt;</code></dt>
        <dd>
            <p>No default value.</p>
            
            <p>The order of codecs, as it will be offered in SDP
            for calls made with ThreeG CodecSet.</p>
        </dd>

        <dt><code>&lt;honorFirstCodec&gt;0&lt;/honorFirstCodec&gt;</code></dt>
        <dd>
            <p>Valid values: <code>0</code> and <code>1</code>.</p>
            
            <p>Default value: <code>0</code>.</p>
            
            <p>Forces the application to use the first codec offered
            by the remote side. Example follows.</p>
            
            <p>An outgoing call with configured codecs 0,102. The remote
            side responds with codecs 102,0 in SDP packet.</p>
            
            <p>With <code>&lt;honorFirstCodec&gt;</code> set to off,
            <code>libsoftphone</code> will start sending audio using "0" codec
            (&mu;-law), the remote side will probably send audio using "102"
            codec (iLBC), so inbound and outbound audio will be coded differently.</p>
            
            <p>In case <code>&lt;honorFirstCodec&gt;</code> is on,
            <code>libsoftphone</code> ignores the user preferred codecs
            of "0,102" and sends the audio using the first codec proposed
            by remote side &mdash; iLBC.</p>
        </dd>

        <dt><code>&lt;ptime&gt;20&lt;/ptime&gt;</code></dt>
        <dd>
            <p>Default value: 20</p>
            <p>packet time in milliseconds, to be used with WiFi codecset.</p>
        </dd>

        <dt><code>&lt;ptime3G&gt;30&lt;/ptime3G&gt;</code></dt>
        <dd>
            <p>Default value: 30</p>
            <p>packet time in milliseconds, to be used with 3G codecset.</p>
        </dd>

        <dt><code>&lt;forcePtime&gt;0&lt;/forcePtime&gt;</code></dt>
        <dd>
            <p>0</p>
            <p>If set to 1, the ptime parameter will be used even if the remote side requests a different value.</p>
        </dd>

        <dt><code>&lt;forcePtime3G&gt;0&lt;/forcePtime3G&gt;</code></dt>
        <dd>
            <p>0</p>
            <p>If set to 1, the ptime3G parameter will be used even if the remote side requests a different value.</p>
        </dd>

        <dt><code>&lt;dtmfOrder&gt;rfc2833,info,audio&lt;/dtmfOrder&gt;</code></dt>
        <dd>
            <p>Valid value is a comma separated list of:
            <code>rfc2833</code>, <code>info</code> and <code>audio</code>.</p>
            <p>Default value: <code>rfc2833,info,audio</code></p>
            <p>The methods to use when generating DTMF events.
            The methods are tried in the order specified here.</p>
            <p><code>rfc2833</code> method is only used when the remote
            side supports telephone-event RTP payload.</p>
        </dd>

        <dt><code>&lt;dtmfAll&gt;0&lt;/dtmfAll&gt;</code></dt>
        <dd>
            <p>Valid values: <code>0</code> and <code>1</code>.</p>
            <p>Default value: <code>0</code>.</p>
            <p>When set, all supported DTMF modes will be sent together.
            By default, the first possible method from &lt;dtmfOrder&gt; is used.</p>
        </dd>

        <dt><code>&lt;STUN&gt;stun.example.com:[port]&lt;/STUN&gt;</code></dt>
        <dd>
            <p>No default value.</p>
            <p>STUN server to use. When empty, <code>libsoftphone</code>
            will make a DNS SRV query for <code>_stun._udp.sipserver</code>
            and uses the returned address. If no port is specified, 3478 is used.</p>
            <p>To force-disable STUN server, set it to an invalid value,
            like <code>0.0.0.0</code>.</p>
        </dd>

        <dt><code>&lt;STUNUsername&gt;user&lt;/STUNUsername&gt;</code></dt>
        <dd>
            <p>default: empty</p>
            <p>Username for STUN/TURN server. If filled in, we'll consider the STUN server TURN-capable.</p>
        </dd>
        <dt><code>&lt;STUNPassword&gt;user&lt;/STUNPassword&gt;</code></dt>
        <dd>
            <p>default: empty</p>
            <p>Password for STUN/TURN server.</p>
        </dd>
        
        <dt><code>&lt;natTraversal&gt;auto&lt;natTraversal&gt;</code></dt>
        <dd>
            <p>Valid values: <code>off</code>, <code>auto</code>, <code>stun</code>, <code>turnAlways</code>, <code>ice</code>.</p>
            <p>Default value: <code>off</code>.</p>
            <p><code>off</code> will always send local/private IP address detected from local netowrk interface. No public address resolution is done.</p>
            <p><code>auto</code> will do a STUN query for a public address. If symmetric NAT is not detected, the global address is used. In case of symmetric NAT, TURN server is used if STUNUsername is filled in, otherwise private/local address is used.</p>
            <p><code>stun</code> will do a STUN query and always use the obtained public address.</p>
            <p><code>turnAlways</code> will always use TURN server</p>
            <p><code>ice</code> will use the ICE process to choose the best address</p>
        </dd>
        <dt><code>&lt;contactIP&gt;internal&lt;/contactIP&gt;</code></dt>
        <dd>
            <p>Valid values: <code>internal</code>, <code>external</code>, <code>static</code></p>
            <p>Default: internal</p>
            <p><code>internal</code> will use the local/private in the Contact and Via SIP header.</p>
            <p><code>external</code> will try to determine the public address using STUN ping, OPTIONS packet or STUN server and use it in Contact and Via header.</p>
            <p><code>internal</code> will use a static address in Contact and Via header, the address is specified in forcedContact node</p>
        </dd>
        <dt><code>&lt;forcedContact&gt;192.168.100.100:7777&lt;/forcedContact&gt;</code></dt>
        <dd>
            <p>Default:empty</p>
            <p>This IP address will be used in Contact and Via headers in case contactIP is set to "static"</p>
            
        </dd>        
        
        <dt><code>&lt;sendAudioBack&gt;0&lt;/sendAudioBack&gt;</code></dt>
        <dd>
            <p>Valid values: <code>0</code>, <code>1</code></p>
            <p>Defalut: 1</p>
            <p>If set to 1, we will always send the audio back to the address from which we receive the audio from the other side.</p>
        </dd>

        <dt><code>&lt;keepAlive&gt;1&lt;/keepAlive&gt;</code></dt>
        <dd>
            <p>Valid values: <code>0</code> and <code>1</code>.</p>
            <p>Default value: <code>0</code>.</p>
            <p>When set, <code>libsoftphone</code> periodically sends keepalive
            packet to SIP server, to keep the connection active and NAT port
            mappings open.</p>
        </dd>
        <dt><code>&lt;keepAlivePeriod&gt;30&lt;/keepAlivePeriod&gt;</code></dt>
        <dd>
            <p>Valid values: integer numeber, values lower than 5 are set to 5</p>
            <p>Default value: <code>30</code>.</p>
        </dd>
        <dt><code>&lt;expires&gt;600&lt;/expires&gt;</code></dt>
        <dd>
            <p>Valid value is an integer in range from 0 to 2<sup>32</sup>&minus;1.</p>
            <p>Default value: <code>600</code>.</p>
            <p>The initial value to send in <code>Expires</code> header when
            registering. The server may negotiate a higher value.</p>
        </dd>

        <dt><code>&lt;incomingDisabled&gt;0&lt;/incomingDisabled&gt;</code></dt>
        <dd>
            <p>Valid values: <code>0</code> and <code>1</code>.</p>
            <p>Default value: <code>0</code>.</p>
            <p>When set, the account will not register for incoming calls.</p>
        </dd>

        <dt><code>&lt;rtpPortRangeStart&gt;10000&lt;rtpPortRangeStart&gt;</code></dt>
        <dt><code>&lt;rtpPortRangeEnd&gt;65530&lt;rtpPortRangeEnd&gt;</code></dt>
        <dd>
            <p>Valid value is an integer in range from 1 to 2<sup>16</sup>&minus;1.</p>
            <p>Default values are: <code>1025</code> and <code>65535</code>.</p>
            <p>The port range to use for RTP sockets.</p>
        </dd>
        
        <dt><code>&lt;videoCodecOrder&gt;34,99&lt;/videoCodecOrder&gt;</code></dt>
        <dd>
            <p>Valid value is a comma separated list of codec numbers.</p>
            
            <p>The order of video codecs, as it will be offered in SDP
            for calls made with Wifi CodecSet.</p>
            
            <p>Supported codecs are:</p>
            
            <dl>
                <dt>34</dt>
                <dd><p>H263</p></dd>
                
                <dt>99</dt>
                <dd><p>H264</p></dd>
            </dl>
        </dd>

        <dt><code>&lt;videoCodecOrder3G&gt;34,99&lt;/videoCodecOrder3G&gt;</code></dt>
        <dd>
            <p>Valid value is a comma separated list of codec numbers.</p>
            
            <p>The order of video codecs, as it will be offered in SDP
            for calls made with 3G CodecSet.</p>
        </dd>
        
        <dt><code>&lt;videoMinKbpsWifi&gt;64&lt;/videoMinKbpsWifi&gt;</code><br/>
            <code>&lt;videoMaxKbpsWifi&gt;384&lt;/videoMaxKbpsWifi&gt;</code></dt>
        <dd>The numbers are in Kilobits per second</dd>
        <dd>
            <p>Bandwidth range for video in case it's being sent over wifi. The encoder is initially configured to produce bitrate in the middle of the given range and
            adjusts the bitrate adaptively towards either end of the range depending on the network conditions.</p>
        </dd>

        <dt><code>&lt;videoMinKbps3G&gt;64&lt;/videoMinKbps3G&gt;</code><br/>
            <code>&lt;videoMaxKbps3G&gt;384&lt;/videoMaxKbps3G&gt;</code></dt>
        <dd>The numbers are in Kilobits per second</dd>
        <dd>
            <p>Bandwidth range for video in case it's being sent over 3G.</p>
        </dd>

        <dt><code>&lt;videoDimsWifi&gt;qcif&lt;/videoDimsWifi&gt;</code></dt>
        <dd>
            <p>Specifies video resolution to be sent over wifi. Supported values are:</p>
            <dl>
                <dt>sqcif</dt>
                <dt>qcif</dt>
                <dt>cif</dt>
                <dt>vga</dt>
                <dt>cif4</dt>
                <dt>cif16</dt>
            </dl>
            </p>H263 codec only supports qcif and cif resolutions. H264 supports all resolutions and in case the device changes orientation from lanscape to portrait or vice-versa, the resolution is automatically transposed.</p>
        </dd>
        
        <dt><code>&lt;videoDimsWifi&gt;qcif&lt;/videoDimsWifi&gt;</code></dt>
        <dd>
            <p>Specifies video resolution to be sent over 3G.</p>
        </dd>
        
        <dt><code>&lt;videoFPSWifi&gt;15&lt;/videoFPSWifi&gt;</code></dt>
        <dd>
            <p>Default value: empty</p>
            <p>Frame rate in frames-per-second which the video encoder should use to encode video streams transfered over Wifi</p>
            <p>When left empty, the library chooses the pre-defined value for the current device. Choosing high framerate means more CPU power is needed to encode the video and less bits can be allocated to a single frame within the bandwidth constraints. When a bitrate is too high, some frames may be dropped if the CPU can't keep up with encoding.</p>
            <p>iOS camera has maximum framrate of 30 fps. The pre-defined fps ranges from 10 for 3GS device to 20 for iPhone 4S.</p>
        </dd>
        <dt><code>&lt;videoFPSWifi&gt;15&lt;/videoFPSWifi&gt;</code></dt>
        <dd>
            <p>Default value: empty</p>
            <p>Frame rate in frames-per-second which the video encoder should use to encode video streams transfered over 3G/cellular network</p>
        </dd>
        
        <dt><code>&lt;allowMessage&gt;1&lt;/allowMessage&gt;</code></dt>
        <dd>
            <p>Valid values: <code>0</code> and <code>1</code>.</p>
            <p>Default value: <code>0</code>.</p>
            <p>When set, MESSAGE will be added to the Allow: list in SIP REGISTER packets. Messaging typically won't work without this set.</p>
        </dd>

        <dt>
            <code>
                &lt;headers&gt;<br/>
                &nbsp;&lt;header method="method" name="name" value="value"/&gt;<br/>
                &nbsp;&lt;header method="method" name="name" value="value"/&gt;<br/>
                &nbsp;... </br>
                &lt;/headers&gt;<br/>
            </code>
            <dd>
                <p>Specify custom headers to be added into SIP packets. Use method="*" to add the header to all SIP packets.
            </dd>
        </dt>
        
        <dt><code>Number Rewriting<pre>
    &lt;rewriting&gt;
        &lt;rule&gt;
            &lt;conditions&gt;
                &lt;condition type="2" param="+"/&gt;
                &lt;condition type="6" param="8"/&gt;
            &lt;/conditions&gt;        
            &lt;actions&gt;
                &lt;action type="2" param="+420"/&gt;            
            &lt;/actions&gt;
        &lt;/rule&gt;
        &lt;rule&gt;
            ... another rule ...
        &lt;/rule&gt;
        ...
    &lt;/rewriting&gt;</pre></code></dt>
        <dd>
            <p>Default value: <code>none</code>.</p>
            <p>Rules are examined in sequence until all conditions of a rule match the dialed number. Then all the actions are applied to the number. If neither of the actions is <code>continue</code> the transformation ends. However, if one of the actions of the rule is <code>continue</code>, another rule is examined and the conditions are now matched against the transformed number (not the originally dialed number).</p>
            <p>The example above means: Add +420 to numbers not starting with + that are longer than 8 digits.
            </p>
            <p><code>condition</code> nodes have two attributes: 
            <code>type</code> encoded as integer (see below) and <code>param</code> - the parameter of the condition
            <dl>
                <dt>1: starts with</dt>
                <dd><p>matches numbers that start with the parameter</p></dd>
                <dt>2: doesn&apos;t start with</dt>
                <dd><p>matches numbers that doesn't start with the parameter</p></dd>
                <dt>3: equals</dt>
                <dd><p>dialed number is exactly the same as the parameter</p></dd>
                <dt>4: length equals</dt>
                <dd><p>the length of the dialed number equals the parameter</p></dd>
                <dt>5: shorter than</dt>
                <dd><p>the length of the dialed number is shorter then the parameter</p></dd>
                <dt>6: longer than</dt>
                <dd><p>the length of the dialed number is longer then the parameter</p></dd>
            </dl>
            </p>
            <p><code>action</code> nodes have two attributes: 
            <code>type</code> encoded as integer (see below) and optional <code>param</code> - the parameter of the action
            <dl>
                <dt>1: replace with</dt>
                <dd><p>applicable only to conditions 1 and 3, replaces the matched part with parameter</p></dd>
                <dt>2: prepend</dt>
                <dd><p>prepends the parameter to the dialed number</p></dd>
                <dt>3: append</dt>
                <dd><p>appends the parameter to the dialed number</p></dd>
                <dt>4: continue</dt>
                <dd><p>no parameter, try following rules as well</p></dd>
           </dl>     
        </dd>

    </dl>
    
    <h3 id="AccountExample">Account Example</h3>
    <pre>&lt;account&gt;
    &lt;username&gt;xxx&lt;/username&gt;
    &lt;password&gt;secret&lt;/password&gt;
    &lt;host&gt;1.2.3.4&lt;/host&gt;
    &lt;codecOrder&gt;9,0,8,102,3&lt;/codecOrder&gt;
    &lt;codecOrder3G&gt;102,3,9,0,8&lt;/codecOrder3G&gt;
&lt;/account></pre>
    
    <h2 id="Preferences">Preferences</h2>
    
    <p>Preference values affect some global features of <code>libsoftphone</code>.
    They are identified by string keys, which store string values.</p>
    
    <dl>
        <dt><code>echoSuppressionEnabled</code></dt>
        <dd>
            <p>Valid values: <code>on</code> and <code>off</code>.</p>
            <p>Default value: <code>off</code>.</p>
            <p>When set to on, <code>libsofthone</code> will use the built&ndash;in
            iPhone echo cancellation support.</p>
        </dd>
        <dt><code>bns</code></dt>
        <dd>
            <p>Valid values: <code>on</code> and <code>off</code>.</p>
            <p>Default value: <code>on</code> on devices with ARMv7 CPU, otherwise off</p>
            <p>When set to on, <code>libsofthone</code> will apply the background noise suppression algorithms to both incoming and outgoing audio. This should produce clearer sound at the cost of some additional CPU load.</p>
        </dd>
        <dt><code>supportBluetooth</code></dt>
        <dd>
            <p>Valid values: <code>on</code> and <code>off</code>.</p>
            <p>Default value: <code>off</code>.</p>
            <p>When set to on, the <code>libsoftphone</code> will enable the bluetooth
            headset audio route. Bluetooth headset can only be selected using the
            <code>MPVolumeView</code> control.</p>
        </dd>
        
        <dt><code>sipTrafficLogging</code></dt>
        <dd>
            <p>Valid values: <code>on</code> and <code>off</code>.</p>
            <p>Default value: <code>off</code>.</p>
            <p>Turns on logging of all SIP traffic and other diagnostic information.
            The content of the log can be obtained using the <code>Instance::Log</code>
            interface.</p>
        </dd>
        
        <dt><code>volumeBoostMicrophone</code></dt>
        <dd>
            <p>Valid values: <code>1 - 8</code>.</p>
            <p>Default value: <code>1</code>.</p>
            <p>Amplify the microphone signal before passing it to codec.</p>
        </dd>
        
        <dt><code>volumeBoostPlayback</code></dt>
        <dd>
            <p>Valid values: <code>1 - 8</code></p>
            <p>Default value: <code>1</code></p>
            <p>Amplify the playback signal before outputting it to device audio.</p>
        </dd>
        <dt><code>audioRtpTosByte</code><br/><code>videoRtpTosByte</code><br/><code>rtcpTosByte</code>
        </dt>
        <dd>
            <p>Valid values: <code>0 - 255</code></p>
            <p>Default values: audio 184, video 136, rtcp 104</p>
            <p>sets the DSCP IP header value of RTP and RTCP packets. Default values are taken from <a href="http://www.cisco.com/en/US/tech/tk722/tk809/technologies_configuration_example09186a00807e9717.shtml">http://www.cisco.com/en/US/tech/tk722/tk809/technologies_configuration_example09186a00807e9717.shtml</a></p>
            <p>note: These values are set only on iOS, Android doesn't seem to support it</p> 
        </dd>
        
    </dl>

    <h2 id="Interface">Interface</h2>

    <h3 id="InstanceSystem">Instance</h3>
    <p>Instance is a structure which holds the internal libsoftphone state and provides several
    specialized interfaces to access its functionality.</p>
    <dl>
        <dt><code>void setObserver( Observer* observer )</code></dt>
        <dd>
            <p>Sets the <code>libsoftphone</code> observer, which receives information
            about registration and call state changes, incoming calls etc.</p>
        </dd>
    </dl>
    <dl>
        <dt><code>Observer * getObserver()</code></dt>
        <dd>
            <p>Gets the previously set observer.</p>
        </dd>
    </dl>
    
    <h3 id="InstanceSystem">Instance::System</h3>
    
    <p>This interface provides some general methods which affect the whole libsoftphone system.</p>
    
    <dl>
        <dt><code>void applicationDidBecomeActive()</code></dt>
        <dt><code>void applicationWillResignActive()</code></dt>
        <dd>
            <p>Theese methods should be called from the app delegate methods of
            the same name. They are important to manage audio sessions during
            transitions between suspend and active modes.</p>
        </dd>
    </dl>
    <dl>
        <dt><code>void applicationDidEnterBackground()</code></dt>
        <dt><code>void applicationWillEnterForeground()</code></dt>
        <dd>
            <p>Theese methods should be called from the app delegate methods of
            the same name. They are important to manage audio sessions during
            transitions between foreground and background application state.</p>
        </dd>
    </dl>
    <dl>
        <dt><code>void applicationIsInBackground() const</code></dt>
        <dt><code>void applicationIsActive() const</code></dt>
        <dd>
            <p>These method return the current application states.</p>
        </dd>
    </dl>
    <dl>
        <dt><code>void ali::string getCpuVersion() const</code></dt>
        <dd>
            <p>Returns the current CPU type. It can currently be "armv6" or "armv7-neon" on iOS, on Android it returns the value of TARGET_ARCH_ABI preprocessor macro defined by NDK.</p>
        </dd>
    </dl>
    
    <h3 id="InstanceRegistration">Instance::Registration</h3>
    
    <p>Provides methods for setting SIP user account credentials, SIP account settings,
    registration / unregistration of SIP user agent and checking the registration state.</p>
    
    <dl>
        <dt><code>bool updateAccount(
            ali::string const&amp; accountXML,
            bool evenIfSame )</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><p><code>ali::string const&amp; accountXML</code></p></dt>
                        <dd>
                            <p>A string which contains SIP account settings in XML format.</p>
                            <p>See <a href="#AccountFormat">Account Format</a>.</p>
                        </dd>
                        
                        <dt><p><code>bool evenIfSame</code></p></dt>
                        <dd>
                            <p>A boolean parameter to force re-registration.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Return Value</dt>
                <dd>
                    <p>Returns <code>false</code> if the accountXML was invalid,
                    otherwise returns <code>true</code>. The re-registration state
                    is reported through the <code>Observer</code> interface.</p>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>When <code>evenIfSame</code> is <code>false</code> and the account
                    is the same as the one set previously, the method will do nothing.
                    If <code>evenIfSame</code> is <code>true</code>, <code>libsoftphone</code>
                    will perform the account DNS SRV resolution, STUN requests and
                    re-registration again, even if the account didn't change. This is useful
                    for refreshing registration after the devices' network settings change.</p>
                </dd>
            </dl>
        </dd>
        
        <dt><code>void unregister()</code></dt>
        <dd>
            <p>Unregisters the active SIP account. The registration state changes are
            reported through the <code>Observer</code> interface.</p>
        </dd>
        
        <dt><code>RegistrationState::Type getRegistrationState()</code></dt>
        <dd>
            <p>Returns the current registration state of the active account.</p>
        </dd>


        <dt><code>void includeNonStandardSipHeader(ali::string const&amp; method, 
                                                 ali::string const&amp; responseCode, 
                                                 ali::string const&amp; name, 
                                                 ali::string const&amp; value)
        </code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><p><code>ali::string const&amp; method</code></p></dt>
                        <dd>
                            <p>SIP method to include the headers in. If the headers should be included in responses, they will be added only to responses to this request. A wildcard value of * is allowed and means "all requests"</p>
                        </dd>
                        
                        <dt><p><code>ali::string const&amp; responseCode</code></p></dt>
                        <dd>
                            <p>Use empty responseCode to add the header to requests.</p>
                            <p>In the following A,B,C stands for any decimal digit and x stands for itself.</p>
                            <p>Use responseCode='xxx' for headers that should be included in all responses.</p>
                            <p>Use responseCode='Axx' for headers that should be included in all responses starting with 'A'.</p>
                            <p>Use responseCode='ABx' for headers that should be included in all responses starting with 'AB'.</p>
                            <p>Use responseCode='ABC' for headers that should be included in responses with code 'ABC'.</p>
                        </dd>
                        <dt><p><code>ali::string const&amp; name</code></p></dt>
                        <dd><p>header name</p></dd>
                        <dt><p><code>ali::string const&amp; value</code></p></dt>
                        <dd><p>header value</p></dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    </p>This method allows you to specify custom SIP header to be sent in outgoing SIP packets. Use the "method" and "responseCode" parameters to specify into which packets the header is to be added</p>
                </dd>
            </dl>
        </dd>
        <dt><code>void excludeNonStandardSipHeader(ali::string const&amp; method, 
                                                 ali::string const&amp; responseCode, 
                                                 ali::string const&amp; name)</code>
                                                 </dt>
        <dd>
            <dl>
                <dt>Remarks</dt>
                <dd>
                    </p>Removes the custom SIP headers added by includeNonStandardSipHeader</p>
                </dd>
            </dl>
        </dd>


        <dt><code>Balance::Record getBalance() const</code>
        </dt>
        <dd>
            <dl>
                <dt>Remarks</dt>
                <dd>
                    </p>Returns the current account balance record. When the balance information becomes available or changes, the event is reported via the Observer interface.</p>
                </dd>
            </dl>
        </dd>

        <dt><code>void networkParametersChanged(Network::Type networkType)</code>
        </dt>
        <dd>
            <dl>
                <dt>Remarks</dt>
                <dd>
                    </p>Whenever the network conditions change is detected (for example, via the Reachability interface on iOS), this method should be called with the new active network type. The call will re-register SIP accounts using the new interface and will also re-invite any active phone calls to continue the call over the new network, possibly after negotiating new codecs.</p>
                </dd>
            </dl>
        </dd>

        
        <dt><code>void updateStreamedAccountsInBackground()</code>
        </dt>
        <dd>
            <dl>
                <dt>Remarks</dt>
                <dd>
                    </p>This method is used on iOS in case TCP backgrounding method is used for incoming calls. It should be called when entering background and also from a keep-alive handler called by iOS, to re-register any SIP accounts which need it. Since iOS keep-awake handler can't be set up for interval shorter than 10 minutes, the SIP expires account parameter must be longer than that to make sure the registration does not expire when the app is suspended in background.</p>
                </dd>
            </dl>
        </dd>
    </dl>
    
    <h3 id="InstanceCalls">Instance::Calls</h3>
    
    <p>Provides methods for handling incoming and outgoing calls.</p>
    
    <dl>
        <dt><code>CallState::Type getCallState(
            ali::string const&amp; callId ) const</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>Id of the call whose call state to read.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Return Value</dt>
                <dd>
                    <p>Returns the current call state of the call specified in the
                    <code>callId</code> parameter.</p>
                </dd>
            </dl>
        </dd>
        
        <dt><code>ali::string call(
            ali::string const&amp; number,
            Call::DesiredMedia media)</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; number</code></dt>
                        <dd>
                            <p>Number or user name to call.</p>
                        </dd>
                        <dt><code>Call::DesiredMedia media</code></dt>
                        <dd>
                            <p>specfies whether to initiate voice call or voice+video call.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Return Value</dt>
                <dd>
                    <p>The method returns a string with new <code>callId</code>.
                    This <code>callId</code> can be used in subsequent calls to
                    <code>Instance::Calls</code> methods.</p>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>The state of the new call will be reported
                    through the <code>Observer</code> interface.</p>
                    
                    <p>The codec set for this call will be chosen automatically
                    based on the current network connection type.</p>
                    
                    <p>Every <code>callId</code> returned from this function must
                    be closed using the <code>close</code> method.</p>
                </dd>
            </dl>
        </dd>

        <dt><code>ali::string call(
            ali::auto_ptr&lt;CallHistory::Record&gt; record,
            Call::DesiredMedia media)</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::auto_ptr&lt;CallHistory::Record&gt; record</code></dt>
                        <dd>
                            <p>a structure which contains information about the called party. Aside from the obvious
                            and required number (stored in "callee" member), it's possible to specify other details like reference to local address
                            book, human-readable title of the callee and there is a string-to-string map where any additional
                            parameters can be stored.</p>
                        </dd>
                        <dt><code>Call::DesiredMedia media</code></dt>
                        <dd>
                            <p>specfies whether to initiate voice call or voice+video call.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Return Value</dt>
                <dd>
                    <p>The method returns a string with new <code>callId</code>.
                    This <code>callId</code> can be used in subsequent calls to
                    <code>Instance::Calls</code> methods.</p>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>The passed <code>record</code> structure is updated during the call by libsoftphone and can be queried by
                    using <a href="#getHistoryRecord">getHistoryRecord(ali::string const&amp; callId)</a> method.</p>
                    
                    <p>Otherwise the method should behave same as the previous variant.</p>
                </dd>
            </dl>
        </dd>
        <a name="getHistoryRecord"></a>
        <dt><code>CallHistory::Record const* getHistoryRecord(ali::string const&amp; callId)</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>id of the call, returned either from <code>call</code> method in case of outgoing calls,
                            or <code>readIncomingCall</code> method for incoming calls.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Return Value</dt>
                <dd>
                    <p>pointer to the structure if it exists, or null otherwise. The pointer should not be stored, libsoftphone will
                    free the structure when the call is disposed using the <code>close</code> method.</p>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>In case of incoming calls, libsoftphone tries to match the incoming numbers with local addressbook and
                    if successfull, the title and contact ID is filled in. For outgoing calls, the same record that was passed
                    to <code>call</code> method is returned, with the call duration updated.</p>
                </dd>
            </dl>
        </dd>

        <dt><code>ali::string readIncomingCall()</code></dt>
        <dd>
            <dl>
                <dt>Return Value</dt>
                <dd>
                    <p>Returns <code>callId</code> of the new call. The call can
                    then be answered or rejected and details about calling party
                    can be queried using the <code>getContact</code> method.</p>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Reads the new incoming call, after it has been reported
                    via <code>onIncomingCall</code> method of the
                    <code>Observer</code> interface.</p>
                    
                    <p>Every <code>callId</code> returned from this function must
                    be closed using the <code>close</code> method.</p>
                </dd>
            </dl>
        </dd>
        
        
        <dt><code>bool isValidCallId(ali::string const&amp; callId) const</code></dt>
        <dd>
            <p>Returns whether a call with the given callID exists.</p>
        </dd>

        
        <dt><code>bool answerIncomingCall(
            ali::string const&amp; callId,
            Call::DesiredMedia media )</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p><code>callId</code> returned from <code>readIncomingCall()</code>.</p>
                        </dd>
                        
                        <dt><code>Call::DesiredMedia media</code></dt>
                        <dd>
                            <p>Specified whether to establish a voice or voice+video call.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Return Value</dt>
                <dd>
                    <p>Returns <code>false</code> if the operation fails (typically,
                    the call timed out), otherwise returns <code>true</code>.</p>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Answers the incoming call with the given media type. The codecs are determined automatically
                    based on current network conditions.</p>
                    
                    <p>The call state transitions can be monitored through the
                    <code>Observer</code> interface.</p>
                </dd>
            </dl>
        </dd>
        
        <dt><code>bool rejectIncomingCall( ali::string const&amp; callId )</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p><code>callId</code> returned from <code>readIncomingCall()</code>.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Return Value</dt>
                <dd>
                    <p>Returns <code>false</code> if the operation fails (typically,
                    the call timed out), otherwise returns <code>true</code>.</p>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Rejects the incoming call.</p>
                    
                    <p>User must still call the <code>close</code> method
                    to free resources owned by the call.</p>
                    
                    <p>The call state transitions can be monitored through the
                    <code>Observer</code> interface.</p>
                </dd>
            </dl>
        </dd>
        
        <dt><code>bool ignoreIncomingCall( ali::string const&amp; callId )</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p><code>callId</code> returned from <code>readIncomingCall()</code>.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Return Value</dt>
                <dd>
                    <p>Returns <code>false</code> if the operation fails (typically,
                    the call timed out), otherwise returns <code>true</code>.</p>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Silences the ringing for the incoming call.</p>
                    
                    <p>User may still call answerIncomingCall or rejectIncomingCall after calling this method to answer / reject the call.</p>
                    
                    <p>The call state transitions can be monitored through the
                    <code>Observer</code> interface.</p>
                </dd>
            </dl>
        </dd>
        <dt><code>bool notifyIncomingRinging(ali::string const&amp; callId)</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p><code>callId</code> returned from <code>readIncomingCall()</code>.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Return Value</dt>
                <dd>
                    <p>Returns <code>false</code> if the operation fails (typically,
                    the call timed out), otherwise returns <code>true</code>.</p>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>When the call arrives and is read via the readIncomingCall() method, the SIP stack has only generated "100 Trying" SIP response back. Calling thie method will generate the "180 Ringing" response.</p>
                    
                    <p>The call state transitions can be monitored through the
                    <code>Observer</code> interface.</p>
                </dd>
            </dl>
        </dd>
        
        <dt><code>bool hold(
            ali::string const&amp; callId,
            bool hold )</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>The call to set hold state on.</p>
                        </dd>
                        
                        <dt><code>bool hold</code></dt>
                        <dd>
                            <p>Pass <code>true</code> to hold,
                            <code>false</code> to unhold.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Sets the hold state of the call.</p>
                    
                    <p>The hold state transition is reported through the
                    <code>Observer</code> interface.</p>
                </dd>
            </dl>
        </dd>
        
        <dt><code>HoldStates getHoldStates( ali::string const&amp; callId )</code></dt>
        <dd>
            <p>Returns the current hold states (both local and remote)
            of the call identified by <code>callId</code>.</p>
        </dd>

        
        <dt><code>void startSimulatedMicrophone(ali::string const&amp; soundToPlay)</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; soundToPlay</code></dt>
                        <dd>
                            <p>Path to a WAV or CAF file to play. The file must be PCM16 or IMA4 (adpcm) encoded with frequency 8000 or 16000Hz and can be mono or stereo. If it's stereo, it's converted to mono automatically.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Microphone signal is replaced by sound from the provided file. In situation when the microphone is taken away from the app (for example, by an incoming GSM call on iOS), this allows the user to play an explanatory message.</p>
                </dd>
            </dl>
        </dd>
        <dt><code>void stopSimulatedMicrophone()</code></dt>
        <dd>
            <dl>
                <dt>Remarks</dt>
                <dd>
                    <p>Stops any simulated microphone set up by the previous method. If the microphone signal is available, it will be re-connected to any active call which exists.</p>
                </dd>
            </dl>
        </dd>

        <dt><code>void isSimulatedMicrophone()</code></dt>
        <dd>
            <dl>
                <dt>Remarks</dt>
                <dd>
                    <p>Returns whether a simulated microphone is installed.</p>
                </dd>
            </dl>
        </dd>
        
        
        <dt><code>bool close( ali::string const&amp; callId )</code></dt>
        <dd>
            <p>Closes the call identified by <code>callId</code>.
            If the call was established, is it hung up.</p>
            
            <p>This function must be called for every <code>callId</code>
            obtained, to free all resources owned by the call.</p>
        </dd>
        
        <dt><code>Contact getContact( ali::string const&amp; callId ) const</code></dt>
        <dd>
            <p>Returns information about the remote side of the
            call identified by <code>callId</code>.</p>
        </dd>
                
        <dt><code>Call::Statistics getStatistics( ali::string const&amp; callId )</code></dt>
        <dd>
            <p>Returns the Statistics structure filled with the stats of the current call. The packetLoss 
            and jitter members are reset to zero, the average and maximum
            is measured for the time intervals between calls to this function.            
            </p>
        </dd>
        
        <dt><code>void getPayloadNumbers( ali::string const&amp; callId, ali::string const&amp; incoming, ali::string const&amp; outgoing )</code></dt>
        <dd>
            <p>Returns the currently used RTP media payload types, or an empty string if no RTP traffic is being sent / received.          
            </p>
        </dd>
        <dt><code>ali::string getCodecString(ali::string const&amp; callId) const</code></dt>
        <dd>
            <p>Returns the codecs used for incoming/outgoing audio as strings.          
            </p>
        </dd>

        <dt><code>ali::string findSipHeader( ali::string const&amp; callId, ali::string const&amp; headerName )</code></dt>
        <dd>
            <p>The internal call object maintains a map of all SIP headers present in the call establishing dialog (incoming INVITE messages and responses). In case the
            header already exists and a new packet is already present in the map, it's overwritten.
            </p>
            <p>
            The headers are stored in the format after parsing, in XML format. Basic headers have a format &lt;HeaderName&gt;value&lt;/HeaderName&gt;, complex headers like
            Contact or Via can be stored as a non-flat XML tree.
            </p>
            <p>
            In case no such header was received, the function returns an empty string. If the header was received and had an empty value, the resut will be 
            &lt;HeaderName/&gt;
            </p>
        </dd>

        <dt><code>bool close( ali::string const&amp; callId )</code></dt>
        <dd>
            <p>Closes the call identified by <code>callId</code>.
            If the call was established, is it hung up.</p>
            
            <p>This function must be called for every <code>callId</code>
            obtained, to free all resources owned by the call.</p>
        </dd>
        
        <dt><code>Contact getContact( ali::string const&amp; callId ) const</code></dt>
        <dd>
            <p>Returns information about the remote side of the
            call identified by <code>callId</code>.</p>
        </dd>
        
        <dt><code>ResponseStatusLine getInviteResponseStatusLine(ali::string const&amp; callId)</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>callId of the call we want to query.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Returns the exact status line from SIP response to the call identified by callId.</p>
                </dd>
            </dl>
        </dd>

        <dt><code>Call::Rate::Record getCallRate(ali::string const&amp; callId)</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>callId of the call we want to query.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Returns the rate of the call identified by callId. Call rates are available only if the provider has a web service which provides this information.</p>
                </dd>
            </dl>
        </dd>

        <dt><code>ali::string getDTMFDigits(ali::string const&amp; callId) const</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>callId of the call we want to query.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Returns the digits which were sent to the call using Audio::dtmfOn method (with appendDigit set to true). Useful if you want to display this information to  user.</p>
                </dd>
            </dl>
        </dd>

        <dt><code>ali::string clearDTMFDigits(ali::string const&amp; callId) const</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>callId of the call we want to operate on.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Clears the DTMF digits remembered for the call.</p>
                </dd>
            </dl>
        </dd>

        
        
        <dt><code>bool updateDesiredMedia(ali::string const&amp; callId, Call::DesiredMedia::Type media)</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>callId of the call we want to operate on.</p>
                        </dd>
                        <dt><code>Call::DesiredMedia::Type media</code></dt>
                        <dd>
                            <p>media to be used for the call</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Updates the desired media for the call. Calling this method with different desired media than current will cause a re-invite with updated SDP.</p>
                </dd>
            </dl>
        </dd>

        <dt><code>Call::DesiredMedia::Type getDesiredMedia(ali::string const&amp; callId) const</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>callId of the call we want to query.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Get the current desired media of the call.</p>
                </dd>
            </dl>
        </dd>

        <dt><code>bool isVideoAvailable(ali::string const&amp; callId) const</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>callId of the call we want to query.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Returns true if video has been successfully negotiated and video stream exists in media session.</p>
                </dd>
            </dl>
        </dd>

        <dt><code>bool incomingCallOffersVideo(ali::string const&amp; callId,Network::Type networkType)</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; callId</code></dt>
                        <dd>
                            <p>callId of the call we want to query.</p>
                        </dd>
                        <dt><code>Network::Type networkType</code></dt>
                        <dd>
                            <p>Network type specifies which local video codec set will be used to check for compatible video format.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Should be calle on incoming calls to query whether the incoming SDP contains video section with codecs compatible with currently configured video codecs for the SIP account which this call belongs to. Useful for the GUI to decide whether to show "answer with video" option.</p>
                </dd>
            </dl>
        </dd>

    </dl>
    
    <h3 id="InstanceAudio">Instance::Audio</h3>
    
    <p>Provides methods for controlling mute and speakerphone functions
    and DTMF code generation</p>
    
    <dl>
        <dt><code>void dtmfOn( char key )</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>char key</code></dt>
                        <dd>
                            <p>DTMF key to generate.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Starts generation of DTMF tone, using the method described
                    in SIP account XML format. The tone is generated until
                    <code>dtmfOff</code> is called.</p>
                    
                    <p>In case no call is active, the method generates only a local beep.</p>
                </dd>
            </dl>
        </dd>
        
        <dt><code>void dtmfOff()</code></dt>
        <dd>
            <p>Turns off any previous DTMF tone.</p>
        </dd>
        
        <dt><code>void setMute( bool mute )</code></dt>
        <dd>
            <p>Mutes / unmutes the microphone.</p>
        </dd>
        
        <dt><code>bool isMute()</code></dt>
        <dd>
            <p>Returns the current mute state.</p>
        </dd>
        
        <dt><code>void setCallAudioRoute(AudioRoute::Type route)</code></dt>
        <dd>
            <p>Switches between in-call audio routes. iOS only allow us to set speakerphone and non-speakerphone, it decices by itself whether the audio will be routed to headset, bluetooth headset or receiver. On Android, wider range of call audio routes is possible.</p>
        </dd>
        
        <dt><code>AudioRoute::Type getCallAudioRoute() const</code></dt>
        <dd>
            <p>Returns the current cal audio route.</p>
        </dd>
    </dl>
    
    <h3 id="InstanceLog">Instance::Log</h3>
    
    <p>When enabled, <code>libsoftphone</code> writes a log of all incoming and outgoing
    SIP traffic and also some other diagnostic information. This interface provides access
    to the log.</p>
    
    <dl>
        <dt><code>ali::string getLog()</code></dt>
        <dd>
            <p>Returns the content of the current log as <code>ali::string</code>.
            User can use <code>c_str()</code> to get the log as a C-style string.</p>
        </dd>
        
        <dt><code>void clearLog()</code></dt>
        <dd>
            <p>Clears the current log.</p>
        </dd>
    </dl>
    
    <h3 id="InstanceSettings">Instance::Settings</h3>
    
    <p>Interface for setting global <code>libsoftphone</code> configuration parameters.
    The parameters are described separately. See <a href="#Preferences">Preferences</a>.</p>
    
    <dl>
        <dt><code>void setOptionValue(
            ali::string const&amp; key,
            ali::string const&amp; value )</code></dt>
        <dd>
            <dl>
                <dt>Parameters</dt>
                <dd>
                    <dl>
                        <dt><code>ali::string const&amp; key</code></dt>
                        <dd>
                            <p>The option key.</p>
                        </dd>
                        
                        <dt><code>ali::string const&amp; value</code></dt>
                        <dd>
                            <p>The new value for the option.</p>
                        </dd>
                    </dl>
                </dd>
                
                <dt>Remarks</dt>
                <dd>
                    <p>Sets the new option <code>value</code>
                    for the given <code>key</code>.</p>
                </dd>
            </dl>
        </dd>
        
        <dt><code>ali::string const&amp; getOptionValue( ali::string const&amp; key )</code></dt>
        <dd>
            <p>Gets the current value of the given <code>key</code>.</p>
        </dd>

        <dt><code>ali::string const&amp; setUserAgent( ali::string const&amp; ua )</code></dt>
        <dd>
            <p>Allows to set the SIP user agent.</p>
        </dd>

    </dl>
    
</body>
</html>
